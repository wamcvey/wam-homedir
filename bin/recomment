#! /bin/sh
# Originally from the Unix Power Tools second edition 
# Major code fixes by wam

umask 077	# MAKE $temp PRIVATE
temp=/tmp/RECOMMENT$$
trap 'rm -f $temp; exit' 0 1 2 15

cchars=' 	/#*>'		# LEADING CHARACTERS TO PRESERVE (INCL. SPACE, TAB)

case "$1" in
-[0-9]|-[0-9][0-9]|-[0-9][0-9][0-9]) widopt="$1" ;;
"")	# CHECK ENVARIABLE (SILENTLY IGNORE ERRORS SO DON'T SCREW UP TEXT):
	case "$CBLKWID" in
	[0-9]|[0-9][0-9]|[0-9][0-9][0-9]) widopt="-$CBLKWID" ;;
	esac
	;;
*)	# PRINT ERROR, THEN GIVE THEM TEXT BACK (SO vi WON'T DELETE LINES):
	# of course, that's what 'u' is for -- wam
	echo "Usage: `basename $0` [-widthnum].  (Text output with no reformatting.)" 1>&2
	#cat
	exit
	;;
esac
	
cat > $temp

# GET COMMENT CHARACTERS USED ON FIRST LINE; STORE IN $comment:
#comment="`sed -n \"1s/^\([$cchars]*\).*/\1/p\" $temp`"
# must use sed's ability to use arbitrary delims to handle C++/java style
# comments
comment="`sed -n \"1s@^\([$cchars]*\).*@\1@p\" $temp`"
# GET NUMBER OF CHARACTERS IN COMMENT CHARACTER STRING:
# cwidth=`expr "${comment}" : '.*'`
# If comment is a mathematical operator, like '>', then expr will get confused
# and return a syntax error.  To avoid the problem, pad the string with leading
# junk then subtract the junk.  -- wam
cwidth=`expr "_${comment}" : '_.*' - 1 `

keep=`expr "$cwidth" + 1`
# RE-FORMAT THE COMMENT BLOCK.  IF $widopt SET, USE IT:
#colrm 1 $cwidth < $temp |		# STRIP OFF COMMENT LEADER FROM LINES
cut -c ${keep}- < $temp |		# STRIP OFF COMMENT LEADER FROM LINES
fmt $widopt |				# RE-FORMAT THE TEXT, AND
sed "s@^@$comment@"			# PUT THE COMMENT CHARACTERS BACK
